---
# Check to see if we are running in AWS
- name: Check if host is running in AWS
  uri:
    url: http://169.254.169.254/latest/meta-data
    timeout: 2
  register: aws_uri_check
  ignore_errors: yes

- name: Set Flag if running in AWS
  set_fact:
    is_aws: "{{ aws_uri_check.status == 200 }}"
  when: not "'FAILED' in aws_uri_check.stderr"
  ignore_errors: yes

- debug:
    msg:
      - "{{ 'EnvironmentType: AWS' if is_aws else 'EnvironmentType: Non-AWS' }}"
      - "AWS Environment check returned:"
      - "{{ aws_uri_check.status }}"

# Check to see if firewalld is installed
- name: Grab list of all installed packages
  package_facts:
    manager: auto

# Epel Repo Install
- name: Add Epel Yum Repo
  yum:
    name:
      - epel-release
    state: present

# Bind Install
- name: Adding required packages
  yum:
    name:
      - bind
      - bind-utils
      - net-tools
      - iproute
      - bind-dyndb-ldap
    state: present

# Set Variables used in various Bind config tasks
- name: Gather network CIDR
  shell: |
    set -o pipefail
    ip addr | grep inet | grep {{ ansible_default_ipv4.interface }} | awk '{print $2}' | cut -d"/" -f2
  register: subnet_cidr
  failed_when: "'FAILED' in subnet_cidr.stderr"
  ignore_warnings: yes

- debug:
    msg: "Network CIDR set to: {{ subnet_cidr.stdout }}"

- name: Calculate PTR Zone
  shell: |
    set -o pipefail
    ip addr | grep inet | grep {{ ansible_default_ipv4.interface }} | awk '{print $2}' | cut -d"/" -f1 | awk -F"." '{print $3"."$2"."$1}'
  register: ptr_zone
  failed_when: "'FAILED' in ptr_zone.stderr"
  ignore_warnings: yes

- debug:
    msg: "PTR Zone set to: {{ ptr_zone.stdout }}"

- name: Calculate PTR nameserver Id
  shell: |
    set -o pipefail
    ip addr | grep inet | grep {{ ansible_default_ipv4.interface }} | awk '{print $2}' | cut -d"/" -f1 | awk -F"." '{print $4}'
  register: ptr_id
  failed_when: "'FAILED' in ptr_id.stderr"
  ignore_warnings: yes

- debug:
    msg: "PTR Nameserver ID set to: {{ ptr_id.stdout }}"

# Back Named.conf
- name: Backup named.conf
  copy:
    remote_src: True
    src: /etc/named.conf
    dest: /etc/named.conf.backup

# Configure Bind
- name: Configure named.conf
  template: src=named.conf.j2 dest=/etc/named.conf owner=named group=named mode=0775
  notify: Restart Bind Service

- name: Configure named.conf.local
  template: src=named.conf.local.j2 dest=/etc/named/named.conf.local owner=named group=named mode=0775
  notify: Restart Bind Service

- name: Create zones directory to store zone data
  file: path=/etc/named/zones state=directory owner=named group=named mode=0775 recurse=yes

- name: Configure {{ domain }} zone
  template: src=db.zone.j2 dest=/etc/named/zones/db.{{ domain }} owner=named group=named mode=0644
  notify: Restart Bind Service

- name: Configure {{ domain }} PTR zone
  template: src=db.ptrzone.j2 dest=/etc/named/zones/db.{{ ptr_zone.stdout }} owner=named group=named mode=0644
  notify: Restart Bind Service

- name: Start Bind Service
  service: name=named state=started enabled=yes

# Restart Bind Service
- name: Restart Bind Service
  meta: flush_handlers # Force restart handlers to restart now instead of at end of playbook run.

# Check the Bind Service Status
- name: Check Bind Service
  command: service named status
  register: bind_service_status
  when: ansible_distribution_major_version < '7'
  ignore_errors: yes

- name: Check Bind Service
  command: systemctl status named.service
  register: bind_service_status
  when: ansible_distribution_major_version > '6'
  ignore_errors: yes

- debug:
    msg: "{{ bind_service_status.stdout }}"
  ignore_errors: yes

# Configure local resolution to use Bind
- name: Reconfigure /etc/resolv.conf to use local Bind service
  lineinfile:
    dest: /etc/sysconfig/network-scripts/ifcfg-{{ ansible_default_ipv4.interface }}
    state: present
    regexp: '^DNS1='
    line: 'DNS1={{ ansible_default_ipv4.address }}'

- name: Reconfigure /etc/resolv.conf to use local search domain
  lineinfile:
    dest: /etc/sysconfig/network-scripts/ifcfg-{{ ansible_default_ipv4.interface }}
    state: present
    regexp: '^DOMAIN='
    line: 'DOMAIN={{ domain }}'

- name: Tag Network Restart Handler if we are not running in AWS
  command: echo "The network service has been flagged for a restart!"
  notify: Restart Networking Service
  when: not is_aws

# Remove eth0 config if its not the ansible interface.
# The playbook will fail in AWS if the eth0 config is present and the adapter is not eth0
- name: Remove eth0 if ipv4 interface is not eth0
  file:
    path: /etc/sysconfig/network-scripts/ifcfg-eth0
    state: absent
  when: not ansible_default_ipv4.interface == 'eth0' and is_aws

# Restart Networking Service
# We can't restart networking on an EC2 instance, so if running in AWS, skip this step.
- name: Restart Networking Service
  meta: flush_handlers # Force restart handlers to restart now instead of at end of playbook run.
  when: not is_aws

# Check the Network Service Status
- name: Check Network Service
  command: service network status
  register: network_service_status
  when: ansible_distribution_major_version < '7'
  ignore_errors: yes

- name: Check Network Service
  command: systemctl status network.service
  register: network_service_status
  when: ansible_distribution_major_version > '6'
  ignore_errors: yes

- debug:
    msg: "{{ network_service_status.stdout }}"
  ignore_errors: yes

# Set SELinux Contexts
- name: Reconfigure /etc/sysconfig/named SELinux
  lineinfile: dest=/etc/sysconfig/named state=present regexp='^ENABLE_ZONE_WRITE=' line='ENABLE_ZONE_WRITE=yes'

- name: Set SELinux contexts
  seboolean: name=named_write_master_zones state=yes persistent=yes
  ignore_errors: yes

# Configure Firewalld
- name: Stop firewalld service if present
  systemd:
    name: firewalld
    state: stopped
  register: firewalld_service_stop
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'

- debug:
    msg: "{{ firewalld_service_stop.status }}"
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'
  ignore_errors: yes

- name: Add DNS service to firewalld if present
  firewalld:
    service: dns
    permanent: yes
    state: enabled
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'

- name: Add DNS UDP port to firewalld if present
  firewalld:
    port: 53/udp
    permanent: yes
    state: enabled
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'

- name: Start firewalld service if present
  systemd:
    name: firewalld
    state: started
  register: firewalld_service_start
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'
  ignore_errors: yes

- debug:
    msg: "{{ firewalld_service_start.status }}"
  when:
    - ansible_distribution_major_version > '6'
    - '"firewalld" in ansible_facts.packages'
  ignore_errors: yes
